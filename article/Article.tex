%
% Complete documentation on the extended LaTeX markup used for Insight
% documentation is available in ``Documenting Insight'', which is part
% of the standard documentation for Insight.  It may be found online
% at:
%
%     http://www.itk.org/

\documentclass{InsightArticle}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}
% to be able to use options in graphics
\usepackage{graphicx}
% for pseudo code
\usepackage{listings}
% subfigures
\usepackage{subfigure}


%  This is a template for Papers to the Insight Journal. 
%  It is comparable to a technical report format.

% The title should be descriptive enough for people to be able to find
% the relevant document. 
\title{WrapITK: Enhanced languages support\\ for the Insight Toolkit}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
\release{0.1}

% At minimum, give your name and an email address.  You can include a
% snail-mail address if you like.
\author{Ga\"etan Lehmann{$^1$} {\small{and}} Zachary Pincus{$^2$} {\small{and}} Benoit Regrain{$^3$}}
\authoraddress{{$^1$}Unit\'e de Biologie du D\'eveloppement et de la Reproduction, Institut National de la Recherche Agronomique, 78350 Jouy-en-Josas, France\\
{$^2$}Stanford University, CA 94305, USA\\
{$^3$}Creatis, CNRS, 69621 Villeurbanne, France}

\begin{document}
\lstset{language=python}
\maketitle

\ifhtml
\chapter*{Front Matter\label{front}}
\fi


\begin{abstract}
\noindent
ITK is a huge image analysis library, which contains lots of state of the arts
algorithms implementations. However, using it in C++ can be difficult and is
definitively bad suited for prototyping. WrapITK aims to allow classes from ITK
(and custom, classes that interact with ITK) to be "wrapped" for use with
languages like Python, Tcl, and Java.
\end{abstract}

\tableofcontents

\section{Introduction}

WrapITK is a project designed to allow classes from ITK (and custom, classes
that interact with ITK) to be "wrapped" for use with languages like
Python, Tcl, and Java.

Note that ITK already has a wrapping infrastructure. This project aims to be
address the following deficits of the existing wrappers (and others):
\begin{itemize}
  \item  ITK is a huge library, but only a small number of classes are available
in target languages. It become quickly frustrating for the user, especially when
he have to spend lot of time to extend the current set of classes. Even if it is
not yet complete, the WrapITK's set of classes have been highly extended. Moreover,
the user can choose at build time which types and which dimensions he want to wrap.

  \item  The template arguments set is poorly choosen, making sometime impossible
to create a pipeline. In WrapITK, most of the filters have the same input and output
types. Only a few filters allow to change type. This make the types manipulated 
by filters more consistent.

  \item  The python's \verb$InsightToolkit$ module is only strucutred as a big list
of names. This make it nearly unusable in the python interpreter. The python's
module organization is completely changed to be more structured and flexible.

  \item  Lots of types returned by ITK object's methods are not usable in target
languages. For example, the \verb$GetPixel()$ method of the class \verb$itk::Image$
returns a string describing a pointer, but don't return the pixel value. In WrapITK,
most types used in classes are available in target languages.

  \item  Names in target laguages are inconsistents.

  \item  The ITK wrapping system is difficult to understand and maintain. WrapITK was
written -- and thoroughly documented -- to be as easy as possible to understand,
maintain, and extend.

  \item  It is non-trivial to add wrappers for different ITK classes to the system. In
WrapITK, adding a wrapper can be as simple as adding a single file containing a
few well-documented cmake macros.

  \item  It is difficult if not impossible to add original-style ITK wrappers for
external C++ classes that interact with ITK. WrapITK provides explicit hooks for
external C++ classes to be wrapped and even installed in the WrapITK tree so
that they interact seamlessly with the other wrapped classes.

  \item  Once the ITK wrappers are built, using them from within the target languages
is in many cases painful, forcing Python code (for example) to look a lot like
C++ code, but nastier. In particular, template types must be hard-coded into
every function name. WrapITK attempts to address this in Python by providing
run-time lookup of templated types. Additionally, WrapITK ensures that
\verb$SmartPointer$s are always returned and acceptable as input, so no bare pointers
are ever exposed to Python. This is not the case in the standard ITK wrappers.

\end{itemize}

Currently, WrapITK only supports Python properly; Java and Tcl libraries build
correctly but the Java and Tcl support classes for loading these libraries needs
some updating.



\section{User guide}

  \subsection{Installation}

    \subsubsection{Get the software}

A tarball archive is submitted with the article.

To get the last version, the user can get the last version from the darcs repository
with the command 
\verb$darcs get http://voxel.jouy.inra.fr/darcs/contrib-itk/WrapITK/$.

For the user which don't want to use darcs but want the last development version,
a nightly updated archive is available at
\url{http://voxel.jouy.inra.fr/darcs/contrib-itk/WrapITK/WrapITK.tar.gz}.

    \subsubsection{CableSwig}

WrapITK requires ITK and CableSwig to have been previously downloaded and built.
To get CableSwig, simply run:
\verb$cvs -d:pserver:anonymous@public.kitware.com:/cvsroot/CableSwig co CableSwig$
(Note that no cvs login is needed here.)

If you check out CableSwig into the \verb$Insight/Utilities$ directory, then it will be
built as a part of ITK, and will be automatically detected by WrapITK when ITK
is found.

    \subsubsection{Required and optional patches}

WrapITK will work properly with a CVS checkout of ITK from 2006-1-31 or later,
or with the ITK 2.4.1 release. If you are using 2.4.1, there are several
required patches to correct bugs in ITK that must be applied. Follow the
directions in \verb$WrapITK/patches$ to do so. Additionally, there are some optional
patches to the ITK source in \verb$WrapITK/patches/optional$ which can be applied to
either a CVS checkout of ITK or to version 2.4.1. These optional patches provide
better support for python by providing \verb$__str__$ methods and the like.

    \subsubsection{Build options}

After CableSwig and ITK have been (possibly patched) and built, building WrapITK
with cmake is simple. Run ccmake in a new directory with the path to the WrapITK
source tree as the first argument, and provide the locations of the ITK and
CableSwig build trees if ccmake so requests. Build options are relatively
self-explanatory.

Note that each individual filter that is wrapped can declare which dimensions it
should be wrapped for, and what image types it can accept. For example, a filter
could declare that it should only be wrapped for 3D images with floating-point
typed pixels. In this case, then wrappers will only be created if the user has
selected to build 3-dimensional image wrappers and has selected one or more
floating point types (e.g. double or float) in ccmake. Thus, the ccmake
configuration specifies the maximum possible range of image and filter types to
be created, and each filter is wrapped for some subset of that range. 

    \subsubsection{Install WrapITK or use it in the build tree}


  \subsection{Python usage}

     \subsubsection{Configuring python and importing the libraries}

If WrapITK has been installed, then using it from within python is trivial:
simply issue the command \verb$import itk$, and you are ready to go. This
is because WrapITK installs a pth file in the python site-packages directory so
that python knows where to find the itk scripts.

If WrapITK has not been installed, then you will either need to set the
\verb$PYTHONPATH$ environment variable to contain the directory
\verb$/path-to-WrapITK-build/Python$, add  this path to sys.paths within python, or
start python from that directory. After this, \verb$import itk$ will work
properly.


     \subsubsection{Basic Usage}

Most class in the itk python module are "template proxy classes" that
encapsulate all of the template instantiations that were created at build time.
If three-dimensional unsigned char and unsigned short image types were created,
they can be accessed as follows:
\begin{itemize}
  \item \verb$itk.Image[itk.UC, 3]$ or \verb$itk.Image.UC3$
  \item \verb$itk.Image[itk.US, 3]$ or \verb$itk.Image.US3$
\end{itemize}

Filters templated on images can be similarly accessed:
\begin{itemize}
  \item \verb$itk.ImageFileReader[itk.Image[itk.UC,3]]$
  \item or \verb$itk.ImageFileReader[itk.Image.UC3]$
  \item or even \verb$itk.ImageFileReader[image]$ if \verb$image$ is of type \verb$UC3$.
\end{itemize}
This makes it easy to write generic routines which
can deal with any input image type.

Each class has a \verb$New()$ method which returns a smart pointer to that class. The
\verb$New()$ method in python has some additional features:
\begin{itemize}
  \item Arguments to the new method are assumed to be filter inputs. So you could
write:
\small \begin{verbatim}
adder = itk.AddImageFilter[...].New()
adder.SetInput1(inputA)
adder.SetInput2(inputB)
\end{verbatim} \normalsize
or you could write
\small \begin{verbatim}
adder = itk.AddImageFilter[...].New(inputA, inputB)
\end{verbatim} \normalsize

  \item Additionally, keyword arguments are allowed as well. Keyword arguments cause
the corresponding \verb$Set...$ method to be called, so you could write the
following:
\small \begin{verbatim}
itk.ImageFileWriter[image].New(image, FileName="foo.tif")
\end{verbatim} \normalsize
or
\small \begin{verbatim}
itk.ImageFileWriter[image].New(Input=image, FileName="foo.tif")
\end{verbatim} \normalsize

\end{itemize}

     \subsubsection{Advanced Features}
As an extra bonus, it is possible to view the doxygen documentation for each
class as the python docstring. This string is available as:
\small \begin{verbatim}
print itk.Image.__doc__
\end{verbatim} \normalsize
or even better (if you use iPython)
\small \begin{verbatim}
itk.Image?
\end{verbatim} \normalsize

Several steps are necessary to obtain this nirvana, however. First, when
configuring the build in ccmake, you must set \verb$DOXYGEN_MAN_PATH$ to some directory
where man pages for the ITK classes will be created. Then, after the build, you
must run \verb$make_doxygen_config.py$ from within the \verb$Python$ directory in the build
directory, to collect information about the wrapped classes and create a doxygen
configuration file to make these man pages. Finally, run doxygen with that
configuration file. After these three simple steps, class docstrings will
contain the man page information. Note that this is limited to systems which
support the python \verb$commands$ module, and which have \verb$groff$ in the path. This
basically means anything but windows will work. (Cygwin should work too.)

In addition (as mentioned above), WrapITK by default ensures that no bare
pointers are ever returned to python: instead reference-counting \verb$SmartPointer$s
are used. However, there may be times when extracting a bare pointer or creating
a new \verb$SmartPointer$ is necessary. To get a bare pointer from a smart pointer, use
the \verb$GetPointer()$ method, as in ITK proper. To create a new smart pointer, the
\verb$SmartPointer$ template proxy class can be used just as above:
\small \begin{verbatim}
smartPtr = itk.SmartPointer[itk.Image[itk.US, 2]](image.GetPointer())
\end{verbatim} \normalsize
or just
\small \begin{verbatim}
smartPtr = itk.SmartPointer[image](image.GetPointer())
\end{verbatim} \normalsize

    \subsection{TCL usage}

    \subsection{Java usage}



\section{Developer guide}

What follows is a brief description of how the WrapITK build system works, how
it can be extended, and how to write external projects.

  \subsection{WrapITK description}

     \subsubsection{Creating a CMakeLists.txt file for a wrapper library}
Each WrapITK sub-library (e.g. \verb$ITKCommonA$, or \verb$ITKAlgorithms$) lives in a
sub-directory of the WrapITK project (e.g. \verb$CommonA$ or \verb$Algorithms$) with a
\verb$CMakeLists.txt$ file that describes how that library  and language support files
(e.g. python template definitions) is to be created. Moreover, any external
project will need a similar file to describe how to create that library.

See \verb$SampleCMakeLists.txt$ in this directory for a description of each macro and
option that can appear in such a file. What follows is the usual set of commands
that will appear:

\small \begin{verbatim}
BEGIN_WRAPPER_LIBRARY("MySpatialObjectExtensions")
SET(WRAPPER_LIBRARY_DEPENDS ITKSpatialObject ITKCommonA)
SET(WRAPPER_LIBRARY_LINK_LIBRARIES ITKCommon)
WRAPPER_LIBRARY_CREATE_WRAP_FILES()
WRAPPER_LIBRARY_CREATE_LIBRARY()
\end{verbatim} \normalsize

\begin{itemize}
  \item \verb$BEGIN_WRAPPER_LIBRARY()$ sets up the environment to wrap a set of classes into a
library with a given name. This macro is defined in \verb$itkConfigWrapping.cmake$
\verb$WRAPPER_LIBRARY_DEPENDS$ stores the list of WrapITK libraries on which the
current library depends (e.g. which libraries wrap classes like \verb$Image$ or
\verb$SpatialObject$, that are going to be used in the current library). Every project
should at least depend on \verb$ITKCommonA$.

  \item \verb$WRAPPER_LIBRARY_LINK_LIBRARIES$ stores a set of other libraries to add at link
time. This can be 3rd party libraries that you will use (be sure to properly set
\verb$LINK_DIRECTORIES$ in this case), or more commonly, the ITK libraries that need to
be linked in, like \verb$ITKCommon$, \verb$ITKIO$, or other. 

  \item \verb$WRAPPER_LIBRARY_CREATE_WRAP_FILES()$ scans all of the \verb$wrap_XXX.cmake$ files in the
current directory and uses the directives within to create CableSwig input files
for these classes. Information about template instantiations is also recorded
for the language support files that are created next. This macro is defined in
\verb$CreateCableSwigInputs.cmake$, and calls language support macros from
\verb$CreateLanguageSupport.cmake$.

  \item Finally, \verb$WRAPPER_LIBRARY_CREATE_LIBRARY()$ creates rules to parse the CalbeSwig
inputs and compile a wrapper library. This macro also causes various language
support files to be created (python only currently) which make it easy to load
that library in python, and which know about the template instances defined.
This macro is defined in \verb$CreateWrapperLibrary.cmake$, and calls language support
macros from \verb$CreateLanguageSupport.cmake$.
\end{itemize}


     \subsubsection{Creating wrapXXX.cmake files to wrap classes}

A \verb$wrap_XXX.cmake file$ defines a group of classes and/or template instantiations
to be wrapped. Often one such file is defined for each class wrapped, but this
is not strictly necessary.

Within such a file, directives are issued to wrap classes and particular
template instances. All of the available directives are defined and documented
in CreateCableSwigInputs.cmake. The basics are presented here:

\begin{itemize}
  \item \verb$WRAP_INCLUDE("header.h")$ -- causes the named header to be \verb$#included$ in the
generated files. 

  \item \verb$WRAP_CLASS("fully_qualified::ClassName" [POINTER|POINTER_WITH_SUPERCLASS])$ --
causes a templated class to be wrapped. All namespaces must be included in the
class name, and note that no template instantiation is given. Template
instantiations are created with various \verb$WRAP$ directives, described below,
between invocations of \verb$WRAP_CLASS()$ and \verb$END_WRAP_CLASS()$.

\verb$WRAP_CLASS$ issues an implicit call to \verb$WRAP_INCLUDE("ClassName.h")$, so the header
for the wrapped class itself does not need to be manually included. To disable
this behavior, set \verb$WRAPPER_AUTO_INCLUDE_HEADERS$ to \verb$OFF$.

The final optional parameter to \verb$WRAP_CLASS$ is \verb$POINTER$ or
\verb$POINTER_WITH_SUPERCLASS$. If no options are passed, then the class is wrapped
as-is. If \verb$POINTER$ is passed, then the class and the typedef'd \verb$class::Pointer$
type is wrapped. (\verb$Class::Pointer$ had better be a \verb$SmartPointer$ instantiation, or
things won't work. This is always the case for ITK-style code.) If
\verb$POINTER_WITH_SUPERCLASS$ is provided, then \verb$class::Pointer$, \verb$class::Superclass$ and
\verb$class::Superclass::Pointer$ are all wrapped. (Again, this only works for
ITK-style code where the class has a typedef'd \verb$Superclass$, and the superclass
has Self and \verb$Pointer$ typedefs.)

  \item \verb$WRAP("mangled_suffix" "template parameters")$ -- When issued between \verb$WRAP_CLASS$
and \verb$END_WRAP_CLASS$, this command causes a particular template instantiation of
the current class to be wrapped. The parameter \verb$mangled_suffix$ is a suffix to
append to the class's name that uniquely identifies this particular template
instantiation, and "template parameters" are whatever should go between the \verb$< >$
template instantiation brackets. (Do not include the brackets.) If you are
wrapping a filter, there are simpler macros to use, which are defined at the
bottom of \verb$CreateCableSwigInputs$ and described below.

  \item \verb$WRAP_type(size)$ (where 'type' is \verb$INT$, \verb$SIGN_INT$, \verb$REAL$, \verb$VECTOR_REAL$,
\verb$COV_VECTOR_REAL$ or \verb$RGB$) -- create a template instantiation with 'size'
\verb$itk::Image$ parameters of the given pixel type. So if you are wrapping a filter
which should take two images with integral pixel types, write \verb$WRAP_INT(2)$. The
specific integral data type(s) (\verb$char$, \verb$long$, or \verb$short$ in the \verb$WRAP_INT$ case) will
be determined by the user-selected build parameters (e.g. \verb$WRAP_long$, and
\verb$WRAP_short$). 

  \item \verb$WRAP_type_DIMS(size dims)$ (with \verb$type$ as above) -- Wrap a filter for certain
dimensions only. Dims should be either a semicolon-separated list of valid
dimensions, or something of the form \verb$'3+'$ to specify that the filter can be
instantiated only for three- and higher-dimensional images. Note that if the
user has not selected to wrap a given dimension at build time, a filter wrapped
with \verb$WRAP_type_DIMS$ will not be instantiated: the final dimensions wrapped are
the {/em intersection} of the user-selected dimensions and the valid dimensions
declared with \verb$WRAP_type_DIMS$.

  \item \verb$END_WRAP_CLASS()$ -- end a block of template instantiations for a particular
class.

  \item \verb$WRAP_NON_TEMPLATE_CLASS("fully_qualified::ClassName" [POINTER|POINTER_WITH_SUPERCLASS])$
 -- Same as \verb$WRAP_CLASS$, but creates a wrapper
for a non-templated class. No \verb$END_WRAP_CLASS()$ is necessary after this macro
because there is no block of template instantiating commands to close.
\end{itemize}


  \subsection{Extending or customizing WrapITK}

To minimize build times and library size, it is possible to manually prevent
various classes from being wrapped. WrapITK is divided into several
sub-libraries, each with a sub-directory: \verb$Algorithms$, \verb$BasicFilters[ABC]$,
\verb$Common[AB]$, \verb$IO$, \verb$Numerics$, \verb$SpatialObject$, and \verb$VXLNumerics$. Within these
directories are sets or \verb$wrap_XXX.cmake$ files, where \verb$XXX$ is the name of the class
(or set of classes) to be wrapped. To prevent one of these classes from being
wrapped, simply rename the file to anything that does {\em not} start with \verb$wrap_$ and
end with cmake. (E.g. append \verb$.notwrapped$ to the name.) (This is probably
unsafe to do in the \verb$Common$, \verb$Numerics$, or \verb$IO$ directories.)

To add classes to be wrapped, it is recommended that you create a simple
{\em External Project} described below. If this is out of the question, you could
create additional \verb$wrap_XXX.cmake$ files in the appropriate directory. (Read on
for instructions as to what to put in these files.)


  \subsection{External projects}

    \subsubsection{Why external projects?}

% In WrapITK/ExternalProjects there are several sample "External Projects" that
% can be built to provide additional functionality to WrapITK and to serve as a
% demonstration for how to create your own such projects. One project is an
% ITK-VTK bridge, and the other is a Python class to allow conversion from
% Numeric/Numarray/numpy matrices to ITK images (and vice-versa).

    \subsubsection{Building}
To build an external project, first ensure that WrapITK has been properly built.
Then use ccmake to configure a build directory for the external project. If
WrapITK has not been installed, you will have to manually enter the path to the
WrapITK build directory.

    \subsubsection{Usage}
Once an external project has been built, it can be tested directly from the
build tree. Start python in the external project build directory's Python
subdirectory, and run the command \verb$import ProjectConfig$ (or 
\verb$import ProjectConfig-[Debug|Release|...]$ if you were using an IDE, depending on which
build configuration was set from the IDE). This command sets up the search paths
properly so that WrapITK and the newly-created library files can be found. Then
type \verb$import ...$ (where \verb$...$ is replaced with the name of the external
project; e.g. \verb$import BufferConversion$), and use the project.

    \subsubsection{Installation}
Simply type \verb$make install$ (or run your IDE's install step) to install the
external project into the WrapITK tree (provided WrapITK has already been
installed). Now the external project can be used just like any of the other
WrapITK libraries, and it will be imported into the \verb$itk$ namespace when the
\verb$import itk$ command is issued from Python. (This can be disabled by setting
\verb$WRAPPER_LIBRARY_AUTO_LOAD$ to \verb$OFF$ in the external project's \verb$CMakeLists.txt$.)

    \subsubsection{Top-level CMakeLists for external projects}
In addition to having a set of \verb$wrap_XXX.cmake$ files and the proper
commands to read in these files and create a library (all described above), an
external project's CMakeLists file needs at least one additional command to
start it out: \verb$FIND_PACKAGE(WrapITK REQUIRED)$.

This command will cause cmake to try to find the WrapITK build/install
directory. If WrapITK has been installed, this will work on the first try.
Otherwise, you will have to set (within ccmake, or in the CMakeLists if you
prefer) the variable \verb$WrapITK_DIR$ to contain the path to the WrapITK build
directory.

    \subsubsection{BufferConversion: an example of extension for one language}

    \subsubsection{ItkVtkGlue: an example of extension for all languages, including C++}


  \subsection{Extending language support and adding more languages}

    \subsubsection{Generating target language code}

    \subsubsection{typemaps}

  \subsection{Contributing to WrapITK}

\section{Acknowledgments}



\section{Conclusion}



% \url{http://www.itk.org}
% \code{Insight/Documentation/Style.pdf}
% \section{Principles of Solar Spot Detection}
% \cite{ITKSoftwareGuide}.
% \doxygen{ImageToImageFilter}

% \small \begin{verbatim}
% \end{verbatim} \normalsize


% The {itemize} environment uses a bullet for each \item.  If you want the 
% \item's numbered, use the {enumerate} environment instead.
% \begin{itemize}
%   \item  Insight Toolkit 2.4.
%   \item  CMake 2.2
% \end{itemize}

% \ref{cthead1}

% \begin{figure}[htbp]
% \centering
% \includegraphics{cthead1}
% \caption{The input image.\label{cthead1}}
% \end{figure}


\appendix



\bibliographystyle{plain}
\bibliography{InsightJournal}
\nocite{ITKSoftwareGuide}

\end{document}

